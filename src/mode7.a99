*********************************************************************
*
* Mode 7 karts demo
* For the TI-99/4A home computer
*
* January 2024 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "sound-defs.a99"

**
* Constants
*
screen_width_char:
       equ  32
screen_height_char:
       equ  30
screen_size_char:
       equ  screen_width_char*screen_height_char
screen_width:
       equ  screen_width_char*8
screen_height:
       equ  screen_height_char*8
background_image_height_char:
       equ  6
bitmap_top:
       equ  background_image_height_char*8
bitmap_width:
       equ  128
bitmap_dst_height:
       equ  63
bitmap_gap_top:
       equ  bitmap_top+bitmap_dst_height
bitmap_gap_height:
       equ  1
bitmap_src_top:
       equ  bitmap_gap_top+bitmap_gap_height
bitmap_src_height:
       equ  128
bitmap_height:
       equ  bitmap_dst_height+bitmap_gap_height+bitmap_src_height
n_char_patterns:
       equ  16
n_sprite_patterns:
       equ  7
max_hw_sprites:
       equ  16
max_sprite_dist:
       equ  >4000
min_sprite_dist:
       equ  >0200
n_other_carts:
       equ  5
**
* Car physics
*
max_power_road:
       equ  >00a0
max_power_terrain:
       equ  >0018
max_reverse_road:
       equ  >0050
max_reverse_terrain:
       equ  >000d
power_factor:
       equ  >0002
reverse_factor:
       equ  >0001
drag:
       equ  >00f4
turn_speed:
       equ  >0010
angular_drag:
       equ  >00f4

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000

**
* VDP memory map
*
gpu_program_tmp:
       equ  >0000
bitmap_base:                           ; 128 x 192 x 4 bbp = 12K
       equ  >0000
bitmap_dst:
       equ  bitmap_base
bitmap_gap:
       equ  bitmap_base + (bitmap_dst_height * bitmap_width / 2)
bitmap_src:
       equ  bitmap_gap + (bitmap_gap_height * bitmap_width / 2)
name_table_2:                          ; Name table 2
       equ  bitmap_src + (bitmap_src_height * bitmap_width / 2) ; = >3000
free_64:                               ; 64 bytes free
       equ  >33c0
name_table:                            ; Name table 1 (note: we only need 6 rows of this)
       equ  >3400
tile_attr_table:                       ; Tile attribute table
       equ  >3500
sprite_attr_table:                     ; Sprite attribute table
       equ  >3580
graphics_data_1:                       ; >200 bytes for scaled sprites (20 bytes free)
       equ  >3600
pattern_table:                         ; Character pattern table plane 0
       equ  >3800
sprite_pattern_table:                  ; Sprite pattern table plane 0 (first >80 bytes used for char patterns)
       equ  >3800
graphics_data_2:                       ; >280 bytes for scaled sprites (196 bytes free)
       equ  >3980
pattern_table_p1:                      ; Character pattern table plane 1
       equ  >3c00
sprite_pattern_table_p1:               ; Sprite pattern table plane 1 (first >80 bytes used for char patterns)
       equ  >3c00
gpu_data:                              ; Data shared between CPU and GPU (>280 bytes)
       equ  >3d80
gpu_program:                           ; Approx. >550 bytes for scaled sprites
       equ  >4000

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
r4lb:
       equ  wrksp+9
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD constants
*
padcon:
       equ  stack+>16                  ; Start of pad constants
one:
       equ  padcon                     ; Constant 1
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  one+2
frame:                                 ; Frame counter
       equ padvar
frame_count:
       equ frame+2
x:                                     ; World x position (FP 8.8, unsigned, 0 <= x < 256)
       equ  frame_count+2
y:                                     ; World y position (FP 8.8, unsigned, 0 <= x < 128)
       equ  x+2
dx:                                    ; Direction vector x (FP 8.8, signed, -1 <= dx <= 1)
       equ  y+2
dy:                                    ; Direction vector y (FP 8.8, signed, -1 <= dy <= 1)
       equ  dx+2
vx:                                    ; Velocity vector x (FP 8.8, signed)
       equ  dy+2
vy:                                    ; Velocity vector y (FP 8.8, signed)
       equ  vx+2
angle:                                 ; View angle, 0 - 255, higher values rotates clockwise (FP 8.8)
       equ  vy+2
angular_velocity:                      ; Angular velocity (FP 8.8)
       equ  angle+2
power:                                 ; Forwards force (FP 8.8)
       equ  angular_velocity+2
reverse:                               ; Backwards force (FP 8.8)
       equ  power+2
skid:                                  ; Is kart skidding?
       equ  reverse+2
max_power:                             ; Max power (FP 8.8)
       equ  skid+2
max_reverse:                           ; Max reverse (FP 8.8)
       equ  max_power+2
speed:                                 ; power - reverse (FP 8.8)
       equ  max_reverse+2
steering:                              ; User input, -1=left, 1=right
       equ  speed+2
throttle:                              ; User input, throttle pressed
       equ  steering+2
brake:                                 ; User input, brake/reverse pressed
       equ  throttle+2
laps:                                  ; Lap completed
       equ  brake+2
check_points:                          ; Progress on current lap (0 - 6)
       equ  laps+1
minutes:                               ; Minutes passed
       equ  check_points+1
seconds:                               ; Second of current minute
       equ  minutes+1
module_speed:
       equ  seconds+1
snd_channel_1:
       equ  module_speed+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
speech_ptr:
       equ  snd_track_3+snd_track_size
get_speech_status:
       equ  speech_ptr+2
vdp_copy_pad:
       equ  get_speech_status+6
pad_max:
       equ  vdp_copy_pad+22

********************************************************************************
*
* Main program
*
       aorg >2000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd
       bl   @one_time_init
       bl   @run_gpu                   ; Run GPU program, which moves it into high GPU RAM
*      Init
       li   r0,music
       bl   @play_module
       bl   @zoom
       bl   @init_level
       bl   @display_time
       bl   @display_lap
       bl   @prepare_to_start
loop:
       bl   @game_loop
       jmp  loop

*********************************************************************************
*
* Run GPU program
*
run_gpu:
       .proc
       li   r0,gpu_program_tmp/256+>3600
       bl   @vwtr
       li   r0,gpu_program_tmp%256+>3700
       bl   @vwtr
       .endproc
*// run_gpu

*********************************************************************
*
* Prepare to start
*
init_level:
       .proc
       li   r0,init_data
       li   r1,x
       li   r2,init_data_end-init_data
       bl   @copy
       bl   @calculate_dx_dy
       bl   @upload_gpu_data
       li   r0,gpu_display_sprites
       seto r1
       bl   @vsww
       .endproc
*// init_level

*********************************************************************
*
* Zoom in on track
*
zoom:
       .proc
       li   r0,gpu_x
       li   r1,>8000
       bl   @vsww
       li   r0,gpu_y
       li   r1,>1000
       bl   @vsww
       li   r3,>1100                   ; Scale
       li   r4,>8000                   ; Angle
zoom_1:
       bl   @vsync
       mov  r4,@angle
       bl   @scroll_background
*      dx
       mov  r3,r0                      ; Scale
       mov  r4,r1                      ; Angle
       bl   @cos                       ; cos(a)
       bl   @mpy_fp88                  ; Scale * cos(a)
       mov  r0,r1
       li   r0,gpu_dx
       bl   @vsww
*      dy
       mov  r3,r0                      ; Scale
       mov  r4,r1                      ; Angle
       bl   @sin                       ; sin(a)
       bl   @mpy_fp88                  ; Scale * sin(a)
       mov  r0,r1
       li   r0,gpu_dy
       bl   @vsww
*      loop
       ai   r4,>0100
       ai   r3,->0010
       ci   r3,>0100
       jhe  zoom_1
       .endproc
*// zoom

*********************************************************************
*
* Prepare to start
*
prepare_to_start:
       .proc
       bl   @game_loop
       li   r0,>3300 + max_hw_sprites + 1
       bl   @vwtr
       li   r0,sprite_attr_table+(max_hw_sprites*4)
       li   r1,count_down_sprite_attrs
       li   r2,4
       bl   @vmbw
       li   r1,phrase_ready_to_start
       bl   @say_phrase
       li   r8,start_notes
       li   r9,4
prepare_to_start_1:
       li   r0,sprite_attr_table+(max_hw_sprites*4)+2
       mov  r9,r1
       dec  r1
       ai   r1,>0020
       swpb r1
       bl   @vsbw
       mov  *r8+,r2
       bl   @start_sound
       mov  @w60,@frame_count
       bl   @wait
       dec  r9
       jne  prepare_to_start_1
       li   r0,>3300 + max_hw_sprites
       bl   @vwtr
       .endproc
start_notes:
       data A1,A1,A1,A3
count_down_sprite_attrs:
       byte >18,>78,>23,>0e
*// prepare_to_start

*********************************************************************
*
* Game loop
*
game_loop:
       .proc
       bl   @vsync
       bl   @display_sprites
       bl   @scroll_background
       bl   @user_input
       bl   @move
       bl   @collisions
       bl   @move_other_karts
       bl   @display_rank
       bl   @upload_gpu_data
       bl   @update_time
       bl   @engine_sound
       bl   @module_player
       bl   @speak
       .endproc
*// game_loop

*********************************************************************
*
* Wait for @frame_count frames
*
wait:
       .proc
wait_1:
       bl   @vsync
       bl   @engine_sound
       bl   @snd_player
       dec  @frame_count
       jne  wait_1
       .endproc
*// wait

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       .proc
       movb @vdpsta,r12
vsync_1:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       .endproc
*// vsync

*********************************************************************************
*
* Display sprites
*
display_sprites:
       .proc
       li   r0,sprite_attr_table
       bl   @vwad
*      Time and lap
       li   r1,top_sprite_attrs
       li   r2,4
       bl   @vdp_copy_pad
*      Kart pattern
       clr  r0
       mov  @power,r1
       ci   r1,>0020
       jlt  display_sprites_1
       mov  @reverse,r1
       jeq  display_sprites_1
       mov  @steering,r0
       mov  @speed,r1
       jgt  display_sprites_1
       neg  r0
display_sprites_1:
       mov  r0,@skid
       sla  r0,2
       ai   r0,kart_patterns_center
*      Kart left sprite
       li   r1,>4e60
       mov  r1,*r15
       swpb r1
       mov  r1,*r15
       mov  *r0+,r1
       mov  r1,*r15
       swpb r1
       mov  r1,*r15
*      Kart right sprite
       li   r1,>4e80
       mov  r1,*r15
       swpb r1
       mov  r1,*r15
       mov  *r0,r1
       mov  r1,*r15
       swpb r1
       mov  r1,*r15
*      Marker on source map
       mov  @y,r1
       andi r1,>7f00
       ai   r1,->0800
       ai   r1,bitmap_src_top*256
       movb r1,*r15
       mov  @x,r1
       ai   r1,->0c00
       movb r1,*r15
       mov  @angle,r1
       ai   r1,>1000                  ; Rotate 45 degrees
       srl  r1,5
       andi r1,>0300
       ori  r1,>1008
       movb r1,*r15
       swpb r1
       movb r1,*r15
*      Markers for other karts
       li   r3,other_karts
       li   r5,n_other_carts
display_sprites_2:
       mov  *r3+,r2                    ; Angle
       mov  *r3+,r0                    ; x
       mov  *r3+,r1                    ; y
       ai   r3,other_kart_size-6       ; Skip other fields
       andi r1,>7f00
       ai   r1,->0800
       ai   r1,bitmap_src_top*256
       movb r1,*r15
       ai   r0,->0c00
       movb r0,*r15
       ai   r2,>1000                  ; Rotate 45 degrees
       srl  r2,5
       andi r2,>0300
       soc  r5,r2
       ori  r2,>1008
       movb r2,*r15
       swpb r2
       movb r2,*r15
       dec  r5
       jne  display_sprites_2
       .endproc
*// display_sprites

*********************************************************************************
*
* Scroll background
*
scroll_background:
       .proc
       mov  @angle,r1
       srl  r1,8
       mov  r1,r0
       sla  r0,2
       andi r0,>00ff
       ori  r0,>1900
       bl   @vwtr
       mov  r1,r0
       sla  r0,1
       andi r0,>00ff
       ori  r0,>1b00
       bl   @vwtr
       .endproc
*// scroll_background

*********************************************************************************
*
* User input
*
user_input:
       .proc
       clr  @throttle
       clr  @brake
       clr  @steering
*      Fire
       li   r0,JOY_FI
       bl   @check_key
       jeq  user_input_1
       mov  @speed,r0
       jlt  user_input_1
       jeq  user_input_1
       seto @brake
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       dec  @steering
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       inc  @steering
user_input_3:
*      Backwards
       tb   3
       jeq  user_input_4
       seto @brake
user_input_4:
*      Forwards
       tb   4
       jeq  user_input_5
       seto @throttle
user_input_5:
       .endproc
*// user_input

*********************************************************************************
*
* Move
*
move:
       .proc
*      Throttle
       li   r0,power_factor
       mov  @power,r1
       abs  @throttle                  ; Check user input
       jeq  move_1
       a    r0,r1                      ; power += power_factor
       c    r1,@max_power
       jlt  move_2
       mov  @max_power,r1              ; Cannot be > max_power
       jmp  move_2
move_1:
       s    r0,r1                      ; power -= power_factor
       jgt  move_2
       clr  r1                         ; Cannot be negative
move_2:
       mov  r1,@power
*      Brake
       li   r0,reverse_factor
       mov  @reverse,r1
       abs  @brake                     ; Check user input
       jeq  move_3
       a    r0,r1                      ; reverse += reverse_factor
       c    r1,@max_reverse
       jlt  move_4
       mov  @max_reverse,r1            ; Cannot be > max_reverse
       jmp  move_4
move_3:
       s    r0,r1                      ; reverse -= reverse_factor
       jgt  move_4
       clr  r1                         ; Cannot be negative
move_4:
       mov  r1,@reverse
*      Can we turn?
       mov  @steering,r0
       jeq  move_9                     ; Not without steering
       mov  @power,r0
       jgt  move_5                     ; Yes with power
       mov  @reverse,r0
       jeq  move_9                     ; Else not without reverse
*      Angular velocity
move_5:
       mov  @angular_velocity,r1
       c    @power,@reverse
       jlt  move_7
*      Angular velocity - forwards direction
       mov  @steering,r0
       jlt  move_6
       ai   r1,turn_speed              ; angular_velocity += turn_speed
       jmp  move_9
move_6:
       ai   r1,-turn_speed             ; angular_velocity -= turn_speed
       jmp  move_9
move_7:
*      Angular velocity - backwards direction
       mov  @steering,r0
       jlt  move_8
       ai   r1,-turn_speed             ; angular_velocity -= turn_speed
       jmp  move_9
move_8:
       ai   r1,turn_speed              ; angular_velocity += turn_speed
move_9:
       mov  r1,@angular_velocity
*      Speed
       mov  @power,@speed              ; speed = power - reverse
       s    @reverse,@speed
*      Directional vector
       bl   @calculate_dx_dy           ; dx = cos(angle), dy = sin(angle)
*      Velocity
       mov  @dx,r0                     ; vx = dx * speed
       mov  @speed,r1
       bl   @mpy_fp88
       mov  r0,@vx
       mov  @dy,r0                     ; vy = dy * speed
       mov  @speed,r1
       bl   @mpy_fp88
       mov  r0,@vy
*      Position
       a    @vx,@x                     ; x += vx
       a    @vy,@y                     ; y += vy
*      Drag
       mov  @vx,r0                     ; vx *= drag
       li   r1,drag
       bl   @mpy_fp88
       mov  r0,@vx
       mov  @vy,r0                     ; vy *= drag
       li   r1,drag
       bl   @mpy_fp88
       mov  r0,@vy
*      Angle
       a    @angular_velocity,@angle   ; angle += angular_velocity
*      Angular velocity
       mov  @angular_velocity,r0       ; angular_velocity *= angular_drag
       li   r1,angular_drag
       bl   @mpy_fp88
       mov  r0,@angular_velocity
       .endproc
*// move

*********************************************************************************
*
* Calculate directional vector
*
calculate_dx_dy:
       .proc
*      dx
       mov  @angle,r1
       bl   @cos
       mov  r1,@dx
*      dy
       mov  @angle,r1
       bl   @sin
       mov  r1,@dy
       .endproc
*// calculate_dx_dy

*********************************************************************************
*
* User collisions
*
collisions:
       .proc
       mov  @x,r0
       movb @y,r1
       bl   @get_map_properties
       mov  r2,r3
       andi r2,>8800                   ; Test if outside track
       jeq  collisions_1
*      Outside track
       jlt  collisions_0
       li   r0,max_power_terrain
       mov  r0,@max_power
       li   r0,max_reverse_terrain
       mov  r0,@max_reverse
       jmp  collisions_2
collisions_0:
*      Border of map
       mov  @vx,r0
       sla  r0,4
       s    r0,@x
       mov  @vy,r1
       sla  r1,4
       s    r1,@y
       jmp  collisions_2
collisions_1:
*      Inside track
       li   r0,max_power_road
       mov  r0,@max_power
       li   r0,max_reverse_road
       mov  r0,@max_reverse
collisions_2:
*      Checkpoint / lap
       andi r3,>7000
       jeq  collisions_4
       srl  r3,4
       sb   @b01,r3
       cb   r3,@check_points
       jne  collisions_4
       ab   @b01,r3
       cb   r3,@b07
       jlt  collisions_3
       movb @b00,@check_points
       ab   @b01,@laps
       bl   @display_lap
       li   r1,phrase_round_completed
       bl   @say_phrase
       jmp  collisions_4
collisions_3:
       movb r3,@check_points
;       li   r1,phrase_check_point
;       bl   @say_phrase
collisions_4:
       .endproc
*// collisions

*********************************************************************************
*
* Move other karts
*
move_other_karts:
       .proc
       li   r3,other_karts
       li   r5,n_other_carts
move_other_karts_1:
       mov  @other_kart_x(r3),r0       ; x
       mov  @other_kart_y(r3),r1       ; y
       bl   @get_map_properties
       mov  r2,r6                      ; Save map properties byte
       mov  @other_kart_slack(r3),r1
       bl   @get_map_direction
       mov  r2,@other_kart_angle(r3)   ; angle
       mov  r1,r4                      ; Save dy
       mov  @other_kart_speed(r3),r1   ; vx
       bl   @mpy_fp88                  ; dx * vx
       a    r0,@other_kart_x(r3)       ; x += dx * vx
       mov  r4,r0                      ; dy
       mov  @other_kart_speed(r3),r1   ; vy
       bl   @mpy_fp88                  ; dy * vy
       a    r0,@other_kart_y(r3)       ; y += dy * speed
*      Progress
       andi r6,>7000                   ; Check for checkpoint
       jeq  move_other_karts_3
       srl  r6,4                       ; Checkpoint index
       mov  @other_kart_laps(r3),r4    ; Get progress
       swpb r4                         ; Swap checkpoints to MSB
       ab   @b01,r4                    ; And increment it
       cb   r4,r6                      ; Check if it matches checkpoint
       jne  move_other_karts_3
       cb   r4,@b07                    ; Did we reach the end?
       jlt  move_other_karts_2
       sb   r4,r4                      ; Reset lap progress
       ab   @b01,@r4lb                 ; Increment lap
move_other_karts_2:
       swpb r4                         ; Swap back
       mov  r4,@other_kart_laps(r3)    ; And save it
move_other_karts_3:
       ai   r3,other_kart_size         ; Next kart
       dec  r5
       jne  move_other_karts_1
       .endproc
*// move_other_karts

*********************************************************************************
*
* Upload GPU data
*
upload_gpu_data:
       .proc
*      x
       li   r0,gpu_x
       mov  @x,r1
       bl   @vsww
*      y
       li   r0,gpu_y
       mov  @y,r1
       bl   @vsww
*      dx
       li   r0,gpu_dx
       mov  @dx,r1
       bl   @vsww
*      dy
       li   r0,gpu_dy
       mov  @dy,r1
       bl   @vsww
*      Other karts
       li   r0,gpu_kart_sprites
       li   r1,other_karts
       li   r2,n_other_carts
upload_gpu_data_1:
       bl   @vwad
       mov  *r1+,r3                    ; Angle
       s    @angle,r3                  ; >ff00
       ai   r3,>2000                   ; Rotate 45 degrees
       srl  r3,13                      ; >0007
       andi r3,>0006                   ; >0006
       ai   r3,other_kart_sprites
       movb *r3+,*r15                  ; Sprite pattern
       movb *r3+,*r15
       movb *r1+,*r15                  ; x
       movb *r1+,*r15
       movb *r1+,*r15                  ; y
       movb *r1+,*r15
       ai   r1,other_kart_size-6       ; Skip other fields
       ai   r0,gpu_sprite_size
       dec  r2
       jne  upload_gpu_data_1
       .endproc
*// upload_gpu_data

*********************************************************************
*
* Update time
*
update_time:
       .proc
       inc  @frame
       mov  @frame,r0
       ci   r0,60
       jlt  update_time_2
       clr  @frame
       ab   @b01,@seconds
       bl   @display_seconds
       cb   @seconds,@b60
       jlt  update_time_2
       sb   @seconds,@seconds
       ab   @b01,@minutes
       bl   @display_time
update_time_2:
       .endproc
*// update_time

*********************************************************************
*
* Display lap
*
display_lap:
       .proc
       li   r1,lap_attrs
       movb @laps,r0
       ab   @b01,r0
       bl   @display_number
       .endproc
*// display_lap

*********************************************************************
*
* Display rank
*
display_rank:
*      Calculate rank
       mov  @laps,r0                   ; Player's progress
       li   r1,n_other_carts+1         ; Calculated rank
       li   r2,n_other_carts
       li   r3,other_karts+other_kart_laps
display_rank_1:
       c    r0,*r3                     ; Compare player's progress to other kart's progress
       jle  display_rank_2
       dec  r1                         ; Move rank forward
display_rank_2:
       ai   r3,other_kart_size
       dec  r2
       jne  display_rank_1
*      Display rank
       swpb r1
       ai   r1,>2000
       movb r1,@rank_attrs+2
       rt
*// display_rank

*********************************************************************
*
* Display time
*
display_time:
       .proc
       bl   @display_minutes
       bl   @display_seconds
       .endproc
*// display_time

*********************************************************************
*
* Display minutes
*
display_minutes:
       .proc
       li   r1,minutes_attrs
       movb @minutes,r0
       bl   @display_number
       .endproc
*// display_minutes

*********************************************************************
*
* Display seconds
*
display_seconds:
       .proc
       li   r1,seconds_attrs
       movb @seconds,r0
       bl   @display_number
       .endproc
*// display_seconds

*********************************************************************
*
* Display number
*
* r0 MSB: number to display
* r1: Address of attributes in CPU RAM
*
display_number:
       .proc
       clr  r3
       mov  r0,r4
       srl  r4,8
       li   r0,10
       div  r0,r3
       mov  r3,r2
       bl   @display_digit
       ai   r1,4
       mov  r4,r2
       bl   @display_digit
       .endproc
*// display_number

*********************************************************************
*
* Display digit
*
* r1: Address of attributes in CPU RAM
* r2: Digit to display
*
display_digit:
       ai   r2,>0020
       swpb r2
       movb r2,@2(r1)
       rt
*// display_digit

*********************************************************************************
*
* Get map pixel
*
* r0: x (FP 8.8)
* r1: y (FP 8.8)
*
* On return r1 MSB contains the pixel value (0-15)
*
get_map_pixel:
       movb r0,r2                      ; XXXXXXXX.xxxxxxxx
       swpb r2                         ; xxxxxxxx.XXXXXXXX
       movb r1,r2                      ; YYYYYYYY.XXXXXXXX
       sla  r2,1                       ; YYYYYYYX.XXXXXXX0
       srl  r2,3                       ; 000YYYYY.YYXXXXXX
       movb @bmp(r2),r1                ; Get 2 source pixels
       andi r0,>0200
       jne  get_map_pixel_1
       srl  r1,4
get_map_pixel_1:
       andi r1,>0f00
       rt
*// get_map_pixel

*********************************************************************************
*
* Get directional vector from map properties byte
*
* r1: Angular bias (FP 8.8)
* r2 MSB: map properties byte
*
* On return:
* r0 contains dx as FP 8.8
* r1 contains dy as FP 8.8
* r2 contains the angle (FP 8.8)
*
get_map_direction:
       .proc
       andi r2,>0700                   ; >0000 - >0700
       sla  r2,5                       ; Angle (FP 8.8)
       a    r1,r2                      ; Add bias
       mov  r2,r1
       bl   @cos
       mov  r1,r0
       mov  r2,r1
       bl   @sin
       .endproc
*// get_map_direction

*********************************************************************************
*
* Get map properties byte
*
* r0: x (FP 8.8)
* r1: y (FP 8.8)
*
* On return:
* r2 contains the map properties byte bcccxddd where:
* - ddd direction 0-7
* - x is set if location is outside road
* - ccc check point number 1-7, or 0 if not a checkpoint
* - b is set if location is at the border of the track
*
get_map_properties:
       srl  r1,4                       ; 0000YYYY.YYYYyyyy
       andi r1,>07c0                   ; 00000YYY.YY000000
       srl  r0,10                      ; 00000000.00XXXXXX
       soc  r0,r1                      ; 00000YYY.YYXXXXXX
       clr  r2
       movb @props(r1),r2            ; >0000 - >4f00
       rt
*// get_map_properties

*********************************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r0,1
       mov  r0,@one
       bl   @clear_pad
       bl   @copy_code_to_pad
       bl   @graphics_mode
       bl   @init_vdp_ram
       .endproc
*// one_time_init

*********************************************************************************
*
* Clear PAD
*
clear_pad:
       li   r1,padvar
       li   r2,pad_max-padvar
clear_pad_1:
       clr  *r1+
       dect r2
       jne  clear_pad_1
       rt
*// clear_pad

*********************************************************************************
*
* Copy code to PAD
*
copy_code_to_pad:
       .proc
       li   r0,vdp_copy
       li   r1,vdp_copy_pad
       li   r2,vdp_copy_end-vdp_copy
       bl   @copy
       li   r0,speech_status_code
       li   r1,get_speech_status
       li   r2,speech_status_code_end-speech_status_code
       bl   @copy
       .endproc
*// copy_code_to_pad

*********************************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       li   r1,vregs2
graphics_mode_1:
       mov  *r1+,r0
       jlt  graphics_mode_2
       bl   @vwtr                      ; Set register
       jmp  graphics_mode_1
*      Return
graphics_mode_2:
       .endproc
*      VDP registers
vregs2:
       byte >39,>1c                        ; Unlock F18A
       byte >39,>1c                        ; Unlock F18A
       byte >00,>00                        ; Graphics I mode
       byte >01,>e1                        ; 16K, display on, interrupts enabled, 8x8 sprites, magnify
       byte >02,name_table/>400            ; Name table
       byte >03,tile_attr_table/>40        ; Tile attribute table
       byte >04,pattern_table/>800         ; Pattern table
       byte >05,sprite_attr_table/>80      ; Sprite attribute table
       byte >06,sprite_pattern_table/>800  ; Sprite pattern table
       byte >07,>01                        ; Backdrop color
       byte >0a,name_table_2/>400          ; Name table 2
       byte >0b,tile_attr_table/>40        ; Tile attribute table 2
       byte >1a,>00                        ; TL2 vertical scroll offset
       byte >1d,>44                        ; 1K bytes between sprite + tile planes
       byte >1f,>d0                        ; Bitmap enable, fat pixels
       byte >20,bitmap_dst/>40             ; Bitmap address
       byte >21,>00                        ; Bitmap x
       byte >22,bitmap_top                 ; Bitmap y
       byte >23,>00                        ; Bitmap width
       byte >24,bitmap_height              ; Bitmap height
       byte >31,>ea                        ; TL2, ROW30, ECM2 tiles + sprites, real y coord
       byte >32,>01                        ; TL2 not always on top
       byte >33,max_hw_sprites             ; Stop sprite
       data -1
*// graphics_mode

*********************************************************************************
*
* Initialize VDP RAM
*
init_vdp_ram:
       .proc
*      Clear all
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Bitmap
       li   r0,bitmap_src
       li   r1,bmp
       li   r2,>2000
       bl   @vmbw
       li   r0,bitmap_gap
       li   r1,>1100
       li   r2,64
       bl   @vsmw
*      Load palette
       li  r0,>2fc0                    ; Reg 47, DPM = 1, AUTO INC = 1
       li  r1,PAL0
       bl   @vwtr
       li  r2,128                      ; 128 bytes for 64 colors
load_palette_loop:
       movb *r1+,*r15                  ; Every two bytes written to the VDP now go to the palette registers
       dec  r2
       jne  load_palette_loop
       li   r0,>2f00                   ; Reg 47, DPM = 0, AUTO INC = 0
       bl   @vwtr
*      Name table
       li   r0,name_table
       li   r1,MD0
       li   r2,background_image_height_char*screen_width_char
       bl   @vmbw
*      Name table_2
       li   r0,name_table_2
       li   r1,MD0+(background_image_height_char*screen_width_char)
       li   r2,background_image_height_char*screen_width_char
       bl   @vmbw
       li   r0,name_table_2+(background_image_height_char*screen_width_char)
       li   r1,>0a00
       li   r2,(screen_height_char-background_image_height_char)*screen_width_char
       bl   @vsmw
*      Tile attributes
       li   r0,tile_attr_table
       li   r1,TAT0                    ; Use palette 1
       li   r2,n_char_patterns
       bl   @vmbw
*      Character patterns
       li   r0,pattern_table
       li   r1,P0_0
       li   r2,n_char_patterns*8
       bl   @vmbw
       li   r0,pattern_table_p1
       li   r1,P1_0
       li   r2,n_char_patterns*8
       bl   @vmbw
*      Sprite patterns
       li   r0,16*8+sprite_pattern_table
       li   r1,S0_4
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,16*8+sprite_pattern_table_p1
       li   r1,S1_4
       li   r2,n_sprite_patterns*32
       bl   @vmbw
*      GPU program
       li   r0,gpu_program_tmp
       li   r1,gpu_prg_start
       li   r2,gpu_prg_end-gpu_prg_start
       bl   @vmbw
*      GPU data
       li   r0,gpu_data
       li   r1,gpu_data_start
       li   r2,gpu_data_end-gpu_data_start
       bl   @vmbw
*      Graphics data
       li   r0,graphics_data_1
       li   r1,gfx_data_1
       li   r2,gfx_data_1_end-gfx_data_1
       bl   @vmbw
       li   r0,graphics_data_2
       li   r1,gfx_data_2
       li   r2,gfx_data_2_end-gfx_data_2
       bl   @vmbw
       .endproc
*// init_vdp_ram

***************************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

***************************************************************************
*
* CPU memory copy
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

***************************************************************************
*
* Program includes
*
       copy "vdp.a99"
       copy "math.a99"
       copy "sound-player.a99"
       copy "module-player.a99"
       copy "sound-fx-routines.a99"
       copy "speech.a99"
gpu_prg_start:
       copy "gpu.a99"
gpu_prg_end:
       equ  $

lower_memory_max:
       equ  $

***************************************************************************
*
* Data
*
       aorg >a000

b00:
       byte 00
b01:
       byte 1
b07:
       byte 7
b60:
       byte 60
w60:
       data 60

init_data:
       data >8000                      ; x
       data >1000                      ; y
       data >0000                      ; dx
       data >0000                      ; dy
       data >0000                      ; vx
       data >0000                      ; vy
       data >8000                      ; angle
       data >0000                      ; angular_velocity
       data >0000                      ; power
       data >0000                      ; reverse
       data max_power_road             ; max_power
       data max_reverse_road           ; max_reverse
init_data_end:
       equ  $

top_sprite_attrs:
       equ  $
minutes_attrs:
       byte >00,>00,>20,>0e
       byte >00,>10,>20,>0e
       byte >00,>20,>2a,>0e
seconds_attrs:
       byte >00,>30,>20,>0e
       byte >00,>40,>20,>0e
rank_attrs:
       byte >00,>78,>26,>0e
lap_attrs:
       byte >00,>e0,>20,>0e
       byte >00,>f0,>20,>0e

other_kart_angle:
       equ  0
other_kart_x:
       equ  2
other_kart_y:
       equ  4
other_kart_speed:
       equ  6
other_kart_slack:
       equ  8
other_kart_laps:
       equ  10
other_kart_checkpoints:
       equ  11
other_kart_size:
       equ  12

other_karts:
       data >8000                      ; angle
       data >6800                      ; x
       data >1000                      ; y
       data >00b0                      ; speed
       data >0100                      ; slack
       data >0000                      ; progress

       data >8000                      ; angle
       data >6800                      ; x
       data >1a00                      ; y
       data >0060                      ; speed
       data >0080                      ; slack
       data >0000                      ; progress

       data >8000                      ; angle
       data >7200                      ; x
       data >1000                      ; y
       data >0080                      ; speed
       data >0000                      ; slack
       data >0000                      ; progress

       data >8000                      ; angle
       data >7200                      ; x
       data >1a00                      ; y
       data >00a0                      ; speed
       data ->0100                     ; slack
       data >0000                      ; progress

       data >8000                      ; angle
       data >7c00                      ; x
       data >1a00                      ; y
       data >0070                      ; speed
       data ->00c0                     ; slack
       data >0000                      ; progress

other_kart_sprites:
       data kart_back_sprite
       data kart_right_sprite
       data kart_front_sprite
       data kart_left_sprite

kart_patterns_left:
       data >1c54,>1854
kart_patterns_center:
       data >1414,>1454
kart_patterns_right:
       data >1814,>1c14

***************************************************************************
*
* Data includes
*
       copy "data.a99"
gpu_data_start:
       copy "gpu-data.a99"
gpu_data_end:
       equ  $
bmp:
       bcopy "track1-bmp.bin"
props:
       copy "track1-props.a99"

       copy "sound-fx.a99"

gfx_data_1:
       data >1800,>2000                ; width in pixels (2 pixels per fat pixel), height in pixels
       bcopy "sprites/barrel.bin"      ; 196 bytes
       data >2800,>1000
       bcopy "sprites/kart-back.bin"   ; 164 bytes
       data >2000,>1000
       bcopy "sprites/kart-left.bin"   ; 132 bytes
gfx_data_1_end:
       equ  $                          ; 492 / 512 bytes

gfx_data_2:
       data >2800,>1000
       bcopy "sprites/kart-front.bin"  ; 164 bytes
       data >2000,>1000
       bcopy "sprites/kart-right.bin"  ; 132 bytes
       data >1800,>1800
       bcopy "sprites/tyres.bin"       ; 148 bytes
gfx_data_2_end:
       equ  $                          ; 444 / 640 bytes

barrel_sprite:
       equ  graphics_data_1
kart_back_sprite:
       equ  barrel_sprite+196
kart_left_sprite:
       equ  kart_back_sprite+164
kart_front_sprite:
       equ  graphics_data_2
kart_right_sprite:
       equ  kart_front_sprite+164
tyres_sprite:
       equ  kart_right_sprite+132

music:
       copy "theme1-music.a99"

upper_memory_max:
       equ  $

       end
