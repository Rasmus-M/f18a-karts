       xorg gpu_program_tmp

*      Copy the GPU program into GPU RAM (>4000 - )
       li   r0,gpu_prg_high_start
       li   r1,gpu_program
       li   r2,gpu_prg_high_end - gpu_program  - gpu_program_tmp
gpu_copy:
       mov  *r0+,*r1+
       dect r2
       jne  gpu_copy
       b    @gpu_program

gpu_prg_high_start:
       equ  $

       xorg gpu_program

       li   r15,>47fe                  ; Stack pointer
gpu_loop:
       idle
       mov  @gpu_dy,r0                 ; nx = dy
       neg  r0                         ; nx = -dy
       mov  @gpu_dx,r1                 ; ny = dx
       mov  @gpu_x,r2                  ; x
       mov  @gpu_y,r3                  ; y
       call @draw_bitmap
       li   r0,barrel_sprite
       li   r1,>1000
       li   r2,>1000
       li   r3,>0100
       li   r4,>0100
       call @draw_scaled_sprite
       jmp  gpu_loop

*********************************************************************************
*
* Draw a rotated, scaled, bitmap
*
* r0: nx is the x-coordinate of the vector orthogonal to the direction vector (FP 8.8)
* r1: ny is the y-coordinate of the vector orthogonal to the direction vector (FP 8.8)
* r2: Center x in source map coordinates x (FP 8.8, XXXXXXXX.xxxxxxxx).
*     Values of 0-255 are within bounds of source map (each wide pixel has two positions).
* r3: Bottom y in source map coordinates y (FP 8.8, YYYYYYYY.yyyyyyyy).
*     Values of 0-127 are within bounds of source map.
*
* Source address is calculated as 000YYYYY.YYXXXXXX
*
draw_bitmap:
*      Init
       li   r4,bitmap_dst + (bitmap_dst_height - 1) * (bitmap_width / 2) ; Destination address (bottom row)
       clr  r5                         ; Row index * 2, bottom row = 0
       clr  r10                        ; For the destination byte (2 pixels)
       li   r11,>0200                  ; Bit in x determining left or right pixel
draw_bitmap_1:
       li   r6,bitmap_width/2          ; Column counter
       push r2                         ; Save x
       push r3                         ; Save y
*      Scale x
       mov  r0,r7                      ; nx
       mov  @scale_table(r5),r8        ; scale
       call @gpu_mpy_fp88              ; Calculate nx * scale in r7 and 64 * nx * scale in r8
       mov  r7,r13                     ; stepX = nx * scale
       sla  r7,6
       s    r7,r2                      ; x -= 64 * stepX (move to left)
       s    r7,r3                      ; y -= 64 * stepX (move forward)
*      Scale y
       mov  r1,r7                      ; ny
       mov  @scale_table(r5),r8        ; scale
       call @gpu_mpy_fp88              ; Calculate ny * scale and 64 * nx * scale in r8
       mov  r7,r14                     ; stepY = ny * scale
       sla  r7,6
       s    r7,r3                      ; y -= 64 * stepY (move to left)
       a    r7,r2                      ; x += 64 * stepY (move forward)
       .ifeq debug,1
       call @plot
       .endif
draw_bitmap_2:
*      Left destination pixel
       mov  r2,r9                      ; XXXXXXXX.xxxxxxxx
       swpb r9                         ; xxxxxxxx.XXXXXXXX
       movb r3,r9                      ; YYYYYYYY.XXXXXXXX
       sla  r9,1                       ; YYYYYYYX.XXXXXXX0
       srl  r9,3                       ; 000YYYYY.YYXXXXXX
       movb @bitmap_src(r9),r10        ; Get 2 source pixels
*      Isolate pixel in left nybble
       coc  r11,r2                     ; Left or right pixel?
       jne  draw_bitmap_3
       sla  r10,4                      ; Move right pixel into position
       jmp  draw_bitmap_3a
draw_bitmap_3:
       andi r10,>f000                  ; Isolate left pixel
draw_bitmap_3a:
*      Move x and y to next pixel
       a    r13,r2                     ; x += stepX
       a    r14,r3                     ; y += stepY
*      Right destination pixel
       mov  r2,r9                      ; XXXXXXXX.xxxxxxxx
       swpb r9                         ; xxxxxxxx.XXXXXXXX
       movb r3,r9                      ; YYYYYYYY.XXXXXXXX
       sla  r9,1                       ; YYYYYYYX.XXXXXXX0
       srl  r9,3                       ; 000YYYYY.YYXXXXXX
       movb @bitmap_src(r9),r12        ; Get 2 source pixels
*      Isolate pixel in right nybble
       coc  r11,r2                     ; Left or right pixel?
       jeq  draw_bitmap_4
       srl  r12,4                      ; Move left pixel into position
       jmp  draw_bitmap_4a
draw_bitmap_4:
       andi r12,>0f00                  ; Isolate right pixel
draw_bitmap_4a:
*      Move x and y to next pixel
       a    r13,r2                     ; x += stepX
       a    r14,r3                     ; y += stepY
*      Write to destination
       socb r12,r10                    ; Combine left and right pixels
       movb r10,*r4+                   ; Write byte (2 pixels) to destination
*      Next column
       dec  r6                         ; Column counter
       jne  draw_bitmap_2
*      Next row
       .ifeq debug,1
       call @plot
       .endif
       pop  r3                         ; Restore y
       pop  r2                         ; Restore x
       ai   r4,-bitmap_width           ; Move destination 2 lines up
       inct r5                         ; Next row index * 2
       ci   r5,bitmap_dst_height*2
       jne  draw_bitmap_1
       ret
*// draw_bitmap

*********************************************************************
*
* Draw a sprite as seen from (@gpu_x, 2gpu_y)
* looking in the direction (@gpu_dx, @gpu_dy)
*
* r0: Address of sprite graphics data (width, height, bitmap)
* r1: Center x position in source map coordinates
* r2: Bottom y position in source map coordinates
*
draw_sprite:
       ret
*// draw sprite

*********************************************************************
*
* Draw a scaled sprite on the destination bitmap.
* Doesn't do any clipping yet!
*
* r0: Address of sprite graphics data (width, height, bitmap)
*     width: in pixels (2 pixels per fat pixel) (FP 8.8)
*     height: in pixels (FP 8.8)
*     bitmap: row by row of bytes packed with 2 fat pixels
* r1: x position (top left corner) in destination map coordinates (FP 8.8)
* r2: y position (top left corner) in destination map coordinates (FP 8.8)
* r3: Scale x (FP 8.8)
* r4: Scale y (FP 8.8)
*
draw_scaled_sprite:
*      Destination address
       swpb r2                         ; yyyyyyyy.YYYYYYYY
       movb r1,r2                      ; XXXXXXXX.YYYYYYYY
       swpb r2                         ; YYYYYYYY.XXXXXXXX
       sla  r2,2                       ; YYYYYYXX.XXXXXX00
       srl  r2,4                       ; 000YYYYY.YYXXXXXX
       ai   r2,bitmap_dst
*      Init
       mov  *r0+,r5                    ; Sprite bitmap width
       mov  *r0+,r6                    ; Sprite bitmap height
       clr  r9                         ; For the source byte (2 pixels)
       clr  r10                        ; For the destination byte (2 pixels)
       li   r11,>0200                  ; Bit in x determining left or right pixel
       clr  r8                         ; Source bitmap y
draw_scaled_sprite_1:
       clr  r7                         ; Source bitmap x
       push r0
       mov  r8,r9                      ; y
       mpy  r5,r9                      ; y * width
       srl  r9,2                       ; / 4 (since width is in normal pixels there are 4 pixels per byte)
       a    r9,r0                      ; Add to source address
       push r2
draw_scaled_sprite_2:
       mov  r7,r9
       srl  r9,10                      ; To byte offset
       a    r0,r9                      ; Add source address of row
       movb *r9,r9                     ; Get source byte
       movb *r2,r10                    ; Get existing destination byte
       coc  r11,r7                     ; Left or right source pixel?
       jeq  draw_scaled_sprite_4
*      Left source pixel
       coc  r11,r1
       jeq  draw_scaled_sprite_3
*      Left source, left destination
       andi r9,>f000
       andi r10,>0f00
       jmp  draw_scaled_sprite_6
draw_scaled_sprite_3:
*      Left source, right destination
       andi r9,>f000
       srl  r9,4
       andi r10,>f000
       jmp  draw_scaled_sprite_6
draw_scaled_sprite_4:
*      Right source pixel
       coc  r11,r1
       jeq  draw_scaled_sprite_5
*      Right source, left destination
       andi r9,>0f00
       sla  r9,4
       andi r10,>0f00
       jmp  draw_scaled_sprite_6
draw_scaled_sprite_5:
*      Right source, right destination
       andi r9,>0f00
       andi r10,>f000
draw_scaled_sprite_6:
       socb r9,r10
       movb r10,*r2
       coc  r11,r1
       jne  draw_scaled_sprite_7
       inc  r2
draw_scaled_sprite_7:
       inv  r1
       a    r3,r7                      ; x += scale x
       c    r7,r5                      ; x > width ?
       jlt  draw_scaled_sprite_2
       pop  r2
       ai   r2,bitmap_width/2          ; Next destination row
       pop  r0
       a    r4,r8                      ; y += scale y
       c    r8,r6                      ; y > height ?
       jlt  draw_scaled_sprite_1
       ret
*// draw_scaled_sprite

*********************************************************************
*
* Signed, fixed point 8.8 multiplication
*
* r7: Multiplicand (FP 8.8)
* r8: Multiplier (FP 8.8)
*
* On return r7 contains the product as FP 8.8.
* Modifies r9.
*
gpu_mpy_fp88:
       clr  r9                         ; Sign (0 means positive)
       mov  r7,r7                      ; Test sign
       jgt  gpu_mpy_fp88_1
       neg  r7                         ; Make positive
       inv  r9                         ; Flip sign (-1 means negative)
gpu_mpy_fp88_1:
       mov  r8,r8                      ; Test sign
       jgt  gpu_mpy_fp88_2
       neg  r8                         ; Make positive
       inv  r9                         ; Flip sign
gpu_mpy_fp88_2:
       mpy  r8,r7                      ; Multiply the numbers
       movb r8,r7                      ; We need the MSB of r8 (decimals)
       swpb r7                         ; And the LSB of r7 (whole number) in reverse order
       mov  r9,r9                      ; Test sign
       jeq  gpu_mpy_fp88_3             ; Jump if sign positive
       neg  r7                         ; Negate result
gpu_mpy_fp88_3:
       ret
*// gpu_mpy_fp88

*********************************************************************
*
* Plot a point on the source bitmap
*
* r2: x (FP 8.8)
* r3: y (FP 8.8)
*
       .ifeq debug,1
plot:
       push r9
       push r10
       push r11
       mov  r2,r9                      ; XXXXXXXX.xxxxxxxx
       swpb r9                         ; 00000000.XXXXXXXX
       movb r3,r9                      ; YYYYYYYY.XXXXXXXX
       sla  r9,1                       ; YYYYYYYX.XXXXXXX0
       srl  r9,3                       ; 000YYYYY.YYXXXXXX
       movb @bitmap_src(r9),r10
       li   r11,>0200
       coc  r11,r2                     ; Left or right pixel?
       jne  plot_1
       andi r10,>f000
       ori  r10,>0100
       jmp  plot_2
plot_1:
       andi r10,>0f00
       ori  r10,>1000
plot_2:
       movb r10,@bitmap_src(r9)
       pop  r11
       pop  r10
       pop  r9
       ret
       .endif
*// plot

*********************************************************************
*
* Data
*
       copy "scale-table.a99"

gpu_prg_high_end:
       equ  $

       aorg
