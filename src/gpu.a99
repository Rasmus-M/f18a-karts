       xorg gpu_program_tmp

*      Copy the GPU program into GPU RAM (>4000 - )
       li   r0,gpu_prg_high_start
       li   r1,gpu_program
       li   r2,gpu_prg_high_end - gpu_program  - gpu_program_tmp
gpu_copy:
       mov  *r0+,*r1+
       dect r2
       jne  gpu_copy
       b    @gpu_program

gpu_prg_high_start:
       equ  $

       xorg gpu_program

       li   r15,>47fe                  ; Stack pointer
gpu_loop:
       idle
       mov  @dx,r0
       mov  @dy,r1
       mov  @x,r2
       mov  @y,r3
       call @draw_bitmap
       jmp  gpu_loop

*********************************************************************************
*
* Draw bitmap
*
* r0: dx is the x-coordinate of the vector that's added to the source map position each step (FP 8.8)
* r1: dy is the y-coordinate of the vector that's added to the source map position each step (FP 8.8)
* r2: Center x in source map coordinates x (FP 8.8, XXXXXXXX.xxxxxxxx).
*     Values of 0-255 are within bounds of source map (each wide pixel has two positions).
* r3: Bottom y in source map coordinates y (FP 8.8, YYYYYYYY.yyyyyyyy).
*     Values of 0-127 are within bounds of source map.
*
* Source address is calculated as 000YYYYY.YYXXXXXX
*
draw_bitmap:
*      Move (x, y) coordinates, which as parameters specify the center bottom,
*      to the left side of the transformed area.
*      x -= 128 * dx, y -= 128 * dy
*      Note that this overflows if dx or dy >= 2 (>0200).
       mov  r0,r13                     ; dx
       sla  r13,7                      ; 128 * dx
       s    r13,r2                     ; x -= 128 * dx
       mov  r1,r14                     ; dy
       sla  r14,7                      ; 128 * dy
       s    r14,r3                     ; y -= 128 * dy
*      Init
       li   r11,>0200                  ; x bit determining left or right pixel
       li   r4,bitmap_dst + (bitmap_dst_height - 1) * (bitmap_width / 2)
       li   r5,bitmap_dst_height
       clr  r10
       mov  r0,r13                     ; dx
       sla  r13,1                      ; 2 * dx
       mov  r1,r14                     ; dy
       sla  r14,1                      ; 2 * dy
draw_bitmap_1:
       li   r6,bitmap_width/2
       mov  r2,r7                      ; Save x
       mov  r3,r8                      ; Save y
draw_bitmap_2:
*      Left destination pixel
       mov  r2,r9                      ; XXXXXXXX.xxxxxxxx
       swpb r9                         ; 00000000.XXXXXXXX
       movb r3,r9                      ; YYYYYYYY.XXXXXXXX
       sla  r9,1                       ; YYYYYYYX.XXXXXXX0
       srl  r9,3                       ; 000YYYYY.YYXXXXXX
       movb @bitmap_src(r9),r10
*      Isolate pixel in left nybble
       coc  r11,r2                     ; Left or right pixel?
       jne  draw_bitmap_3
       sla  r10,4                      ; Move right pixel into position
       jmp  draw_bitmap_3a
draw_bitmap_3:
       andi r10,>f000
draw_bitmap_3a:
*      Move x and y to next pixel
       a    r13,r2                     ; x += 2 * dx
       a    r14,r3                     ; y += 2 * dy
*      Right destination pixel
       mov  r2,r9                      ; XXXXXXXX.xxxxxxxx
       swpb r9                         ; 00000000.XXXXXXXX
       movb r3,r9                      ; YYYYYYYY.XXXXXXXX
       sla  r9,1                       ; YYYYYYYX.XXXXXXX0
       srl  r9,3                       ; 000YYYYY.YYXXXXXX
       movb @bitmap_src(r9),r12
*      Isolate pixel in right nybble
       coc  r11,r2                     ; Left or right pixel?
       jeq  draw_bitmap_4
       srl  r12,4                      ; Move left pixel into position
       jmp  draw_bitmap_4a
draw_bitmap_4:
       andi r12,>0f00
draw_bitmap_4a:
*      Move x and y to next pixel
       a    r13,r2                     ; x += 2 * dx
       a    r14,r3                     ; y += 2 * dy
*      Write to destination
       socb r12,r10                    ; Combine left and right pixels
       movb r10,*r4+                   ; Write byte to destination
*      Next column
       dec  r6
       jne  draw_bitmap_2
*      Next row
       mov  r7,r2                      ; Restore x
       mov  r8,r3                      ; Restore y
       a    r1,r2                      ; x += dy
       s    r0,r3                      ; y -= dx
       ai   r4,-bitmap_width           ; Move destination 2 lines up
       dec  r5
       jne  draw_bitmap_1
       ret
*// draw_bitmap

gpu_prg_high_end:
       equ  $

       aorg
